# -*- coding: utf-8 -*-
"""cogs106proj Andrew and kyrie .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zbtpk2LZgZU9qgyTKBQV6KQdxykjQX46
"""

import numpy as np

class Metropolis:
    def __init__(self, log_target, initial_state):
        self.log_target = log_target
        self.current_state = initial_state
        self.sigma = 1
        self.samples = []

    def _accept(self, proposal):
        acceptance_prob = min(1, np.exp(self.log_target(proposal) - self.log_target(self.current_state)))
        return np.random.uniform() < acceptance_prob

    def adapt(self):
        r_target = 0.4
        n_blocks = 10  # User-defined number of blocks
        block_sizes = [100] * n_blocks  # User-defined block sizes

        for n in block_sizes:
            acceptances = 0
            for _ in range(n):
                proposal = np.random.normal(self.current_state, self.sigma)
                if self._accept(proposal):
                    acceptances += 1
                    self.current_state = proposal

            r_k = acceptances / n
            self.sigma *= (r_target / r_k) ** 1.1

        return self

    def sample(self, n):
        for _ in range(n):
            proposal = np.random.normal(self.current_state, self.sigma)
            if self._accept(proposal):
                self.current_state = proposal
            self.samples.append(self.current_state)

        return self

    def summary(self):
        if not self.samples:
            raise ValueError("No samples available. Call sample() method first.")

        mean = np.mean(self.samples)
        lower_bound = np.percentile(self.samples, 2.5)
        upper_bound = np.percentile(self.samples, 97.5)

        return {
            "mean": mean,
            "95% CI": (lower_bound, upper_bound)
        }
